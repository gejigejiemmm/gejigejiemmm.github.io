<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.64.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>java 多线程的入门学习&nbsp;&ndash;&nbsp;gejigejiemmm</title><link rel="stylesheet" href="/css/core.min.a5d63d306fa53cba7bcef6c96fd6b55a008ea5736acaf25aace71f2bd7b379b2d97257d9c332e405e82f4f6e980f8409.css" integrity="sha384-pdY9MG&#43;lPLp7zvbJb9a1WgCOpXNqyvJarOcfK9ezebLZclfZwzLkBegvT26YD4QJ"><body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/tomato.png" alt /><span class="site name">gejigejiemmm</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="https://github.com/gejigejiemmm/"target="_blank">Github</a><a class="nav item" href="https://gohugo.io/"target="_blank">Hugo</a></nav></div></span></div><div class="site slogan"><span class="title">halo😊</span></div></section><div id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">java 多线程的入门学习</h1><p class="article date">Wednesday, March 4, 2020</p></section><article class="article markdown-body"><h2 id="多线程">多线程</h2>
<h3 id="程序进程线程的基本概念">程序、进程、线程的基本概念</h3>
<p>程序</p>
<p>是为了完成特定的任务，用某种语言编写的一组指令的集合。即指一段特定的静态的代码。</p>
<p>进程</p>
<p>正在运行中的程序，（程序的一次执行过程），加载在内存中，操作系统会为进程分配内存空间，是动态（交换数据）的。</p>
<p>线程</p>
<p>进程进一步划分为线程，是程序内部的一条执行路径。并行的去执行多条线程，称之为多线程。
（新建一条线程：主程序新开一条线程，并行的执行）</p>
<p>进程和线程的关系：一个进程可能会有多个线程，多个线程共享进程的内存资源。</p>
<h3 id="线程的创建和使用">线程的创建和使用</h3>
<h4 id="1-声明一个类继承thread类重写run方法">1. 声明一个类，继承Thread类，重写run()方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 多线程的创建
</span><span class="cm"> * 方式一
</span><span class="cm"> * 继承 Thread
</span><span class="cm"> * 重写 run方法
</span><span class="cm"> * 调用 start方法启动
</span><span class="cm"> *
</span><span class="cm"> * 例子：遍历100以内的偶数
</span><span class="cm"> */</span>

<span class="c1">//1. 继承 Thread 类
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="n">Thread</span><span class="o">{</span>

    <span class="c1">//2. 重写 run 方法
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">100</span><span class="o">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">2</span> <span class="o">=</span><span class="o">=</span> <span class="n">0</span><span class="o">)</span><span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//3. 创建对象
</span><span class="c1"></span>        <span class="n">MyThread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyThread</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="c1">//4. 开始线程
</span><span class="c1"></span>        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>调用start()方法会自动调用该线程的run()方法</p>
<p>问题1 ：那么能否不调用satrt()方法,直接去调用run()方法呢？</p>
<p>不可以！！！！</p>
<p>直接调用run()方法时，实际上还是main线程
Thread.currentThread().getName() 可以使用这个方法获取线程名字测试一下</p>
<p>问题2 ： 能使用start方法，再创建一个线程吗？</p>
<p>不可以！！！！！
一个线程只能开启一次，二次调用 start 则会报 java.lang.IllegalThreadStateException 异常</p>
<h5 id="thread-的常见方法">Thread 的常见方法</h5>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * Thread 的常用方法
</span><span class="cm"> * 1. start() 启动线程
</span><span class="cm"> * 2. run() 当前线程要执行的操作
</span><span class="cm"> * 3. getName() 获取线程的名字
</span><span class="cm"> * 4. currentThread() 静态方法，返回当前执行的线程
</span><span class="cm"> * 5. setName() 设置线程的名字
</span><span class="cm"> * 6. yield() 释放cpu执行权
</span><span class="cm"> * 7. join() 线程a中调用线程b的join方法，a进入阻塞状态，直到线程b执行完毕，然后a继续执行
</span><span class="cm"> * 8. stop() 强制线程结束,已过时
</span><span class="cm"> * 9. sleep() 让当前线程阻塞等待多少秒
</span><span class="cm"> */</span>
</code></pre></div><h5 id="线程的优先级">线程的优先级</h5>
<p>getPriority() 获取优先级
setPriority() 设置优先级</p>
<p>优先级:::</p>
<p>Thread.MAX_PRIORITY 10</p>
<p>Thread.NORM_PRIORITY 5 默认情况下</p>
<p>Thread.MAX_PRIORITY 1</p>
<h4 id="2-实现runnable接口">2. 实现Runnable接口</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 创建多线程的方式二：实现Runnable 接口
</span><span class="cm"> * 1. 创建一个实现Runnable接口的类
</span><span class="cm"> * 2. 实现类去实现Runnable接口的抽象方法: run()
</span><span class="cm"> * 3. 创建实现类的对象
</span><span class="cm"> * 4. 将此对象作为参数传递到Thread类的构造器,创建Thread类的对象
</span><span class="cm"> * 5. 调用start()
</span><span class="cm"> */</span>
<span class="kd">class</span> <span class="nc">MThread</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">100</span><span class="o">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">2</span> <span class="o">=</span><span class="o">=</span> <span class="n">0</span><span class="o">)</span><span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">MThread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MThread</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="c1">//调用的是当前线程的run --》(但是调用了Runnable类型的run方法）
</span><span class="c1"></span>        <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">t1</span><span class="o">)</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h5 id="两种方法的比较">两种方法的比较</h5>
<p>Thread类其实也实现了Runnable接口，所以比较推荐第二种，同时第二种方式也打破了extends的单继承性</p>
<h3 id="线程的生命周期">线程的生命周期</h3>
<p>Thread.State 的变量指代表线程的状态</p>
<p>New：新建，当一个Thread类或其子类的对象被创建时，新生的线程对象处于新建状态</p>
<p>就绪，当线程被satrt()后，将进入线程队列等待cpu的调用</p>
<p>运行，当cpu调用该线程的时候</p>
<p>阻塞，当该线程被人为挂起或执行输入输出操作时，中断自己的执行，让出cpu控制权</p>
<p>死亡，线程完成了自己的任务，或被强制结束，或异常退出后进入死亡状态</p>
<h3 id="线程的同步">线程的同步</h3>
<h4 id="线程的安全问题与解决">线程的安全问题与解决</h4>
<p>问题：卖票过程中出现重票、错票&ndash;&gt;出现了线程安全问题</p>
<p>问题出现的原因：当某个线程在操作车票的过程中，尚未操作完成，其他线程参与进来也操作车票</p>
<p>解决：在一个线程a在操作ticket的时候，其他线程不能参与进来，直到线程a操作完ticket之后，其他线程才可以操作ticket。
即使线程a出现了阻塞，也不能被改变</p>
<p>在java中我们通过同步机制来解决线程安全问题</p>
<p>方式一：同步代码块</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/*
</span><span class="cm">    synchronized(同步监视器){
</span><span class="cm">        需要被同步的代码
</span><span class="cm">    }   
</span><span class="cm">
</span><span class="cm">    说明：
</span><span class="cm">    1。操作共享数据的代码，即为被同步的代码
</span><span class="cm">    2。共享数据：多个线程共同操作的数据
</span><span class="cm">    3。同步监视器，俗称：锁。任何一个类的对象都可以充当锁
</span><span class="cm">        要求：多个线程必须共用同一个锁（同一个对象）
</span><span class="cm">*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WindowRunnableTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">WindowRunnable</span> <span class="n">windowRunnable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WindowRunnable</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">Thread</span> <span class="n">window1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">windowRunnable</span><span class="o">)</span><span class="o">;</span>
        <span class="n">Thread</span> <span class="n">window2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">windowRunnable</span><span class="o">)</span><span class="o">;</span>
        <span class="n">Thread</span> <span class="n">window3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">windowRunnable</span><span class="o">)</span><span class="o">;</span>

        <span class="n">window1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;窗口1&#34;</span><span class="o">)</span><span class="o">;</span>
        <span class="n">window2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;窗口2&#34;</span><span class="o">)</span><span class="o">;</span>
        <span class="n">window3</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;窗口3&#34;</span><span class="o">)</span><span class="o">;</span>

        <span class="n">window1</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">window2</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">window3</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">WindowRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span> <span class="n">100</span><span class="o">;</span>
    <span class="c1">//锁
</span><span class="c1"></span>    <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span><span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span><span class="o">{</span><span class="c1">//synchronized (obj) 或者synchronized (WindowRunnable.class){ 都可以
</span><span class="c1"></span>
                <span class="k">if</span><span class="o">(</span><span class="n">ticket</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span><span class="o">{</span>

                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">10</span><span class="o">)</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span><span class="o">+</span><span class="s">&#34;: 卖票，票号为&#34;</span><span class="o">+</span><span class="n">ticket</span><span class="o">)</span><span class="o">;</span>

                    <span class="n">ticket</span><span class="o">-</span><span class="o">-</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>方式二：同步方法
将被同步的代码提取出来封装成一个方法</p>
<pre><code>    //同步方法中，同步监视器为this
    //如果同步方法被static修饰 同步监视器就为类名.class
    private synchronized void show(){
        if(ticket &gt; 0){
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName()+&quot;: 卖票，票号为&quot;+ticket);

            ticket--;
        }
    }
</code></pre><p>好处：解决了线程的安全问题</p>
<p>坏处：运行慢，变成了串行，操作同步代码时，只能有一个线程参与，相当于单线程的过程，有局限性</p>
<h4 id="懒汉式的线程安全问题">懒汉式的线程安全问题</h4>
<h3 id="线程的通信">线程的通信</h3>
<p>线程间有的时候是需要通信的，比如说最经典的生产者和消费者问题，消费者看到商品里没有货物的时候
，就不再去购买货物了，生产者看到商店货物满了的时候，就不再去生产商品了，假设现在有两个线程，
一个是生产者线程，一个是消费者线程，那么谁来告诉他们商品的情况呢？</p>
<p>这个时候我们就需要使用，线程中的三个通信方法来进行通信了</p>
<ul>
<li>wait()：一旦执行此方法，线程进入阻塞，并且释放同步监视器</li>
<li>notify()：一旦执行此方法，会唤醒一个线程，如果有多个线程，唤醒优先级最高的那个</li>
<li>notifyAll()：一旦执行此方法，会唤醒所有的线程。</li>
<li>说明，这三个方法，只能在同步代码块，或者同步方法当中,Lock有自己的wait</li>
<li>必须由同一个同步监视器调用 wait 和 notify，否则会报异常 java.lang.IllegalMonitorStateException</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 两个线程循环打印 1-100
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CommunicationTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Number</span> <span class="n">number</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Number</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">number</span><span class="o">)</span><span class="o">;</span>
        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">number</span><span class="o">)</span><span class="o">;</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Number</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span><span class="o">{</span>

            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">Number</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>

                <span class="c1">//唤醒一个线程
</span><span class="c1"></span>                <span class="n">Number</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">notify</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

                <span class="c1">//唤醒所有线程
</span><span class="c1"></span>                <span class="c1">//Number.class.notifyAll();
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">number</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">100</span><span class="o">)</span><span class="o">{</span>

                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">100</span><span class="o">)</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span><span class="o">+</span><span class="s">&#34;打印：&#34;</span><span class="o">+</span><span class="n">number</span><span class="o">)</span><span class="o">;</span>
                    <span class="n">number</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>

                    <span class="k">try</span> <span class="o">{</span>
                        <span class="c1">//从就绪态进入阻塞态，而且会释放同步锁，只能由其他线程唤醒。
</span><span class="c1"></span>                        <span class="n">Number</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">wait</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h5 id="生产者消费者问题">生产者消费者问题</h5>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 生产者和消费者问题
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductorAndCustomer</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Clerk</span> <span class="n">clerk</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Clerk</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">Producer</span> <span class="n">producer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Producer</span><span class="o">(</span><span class="n">clerk</span><span class="o">)</span><span class="o">;</span>
        <span class="n">Consumer</span> <span class="n">Consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Consumer</span><span class="o">(</span><span class="n">clerk</span><span class="o">)</span><span class="o">;</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">producer</span><span class="o">)</span><span class="o">;</span>
        <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">Consumer</span><span class="o">)</span><span class="o">;</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;生产者1&#34;</span><span class="o">)</span><span class="o">;</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;消费者1&#34;</span><span class="o">)</span><span class="o">;</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>


    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Clerk</span><span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">productCount</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

    <span class="c1">//生产产品,此时同步监视器是 this
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">produceProduct</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">productCount</span> <span class="o">&lt;</span> <span class="n">20</span><span class="o">)</span><span class="o">{</span>
            <span class="n">productCount</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span><span class="o">+</span><span class="s">&#34;:开始生产第&#34;</span><span class="o">+</span><span class="n">productCount</span><span class="o">+</span><span class="s">&#34;个产品&#34;</span><span class="o">)</span><span class="o">;</span>

            <span class="n">notify</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;仓库满20个&#34;</span><span class="o">)</span><span class="o">;</span>
                <span class="n">wait</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">//消费产品
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">consumeProduct</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">productCount</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span><span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span><span class="o">+</span><span class="s">&#34;:开始消费第&#34;</span><span class="o">+</span><span class="n">productCount</span><span class="o">+</span><span class="s">&#34;个产品&#34;</span><span class="o">)</span><span class="o">;</span>
            <span class="n">productCount</span><span class="o">-</span><span class="o">-</span><span class="o">;</span>

            <span class="n">notify</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;没有商品了&#34;</span><span class="o">)</span><span class="o">;</span>
                <span class="n">wait</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//生产者
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Producer</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>

    <span class="kd">private</span> <span class="n">Clerk</span> <span class="n">clerk</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Producer</span><span class="o">(</span><span class="n">Clerk</span> <span class="n">clerk</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">clerk</span> <span class="o">=</span> <span class="n">clerk</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span><span class="o">+</span><span class="s">&#34;:开始生产&#34;</span><span class="o">)</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span><span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">10</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">clerk</span><span class="o">.</span><span class="na">produceProduct</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//消费者
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Consumer</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>

    <span class="kd">private</span> <span class="n">Clerk</span> <span class="n">clerk</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Consumer</span><span class="o">(</span><span class="n">Clerk</span> <span class="n">clerk</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">clerk</span> <span class="o">=</span> <span class="n">clerk</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span><span class="o">+</span><span class="s">&#34;:开始消费&#34;</span><span class="o">)</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span><span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">10</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">clerk</span><span class="o">.</span><span class="na">consumeProduct</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="jdk-50-新增的创建多线程的方式">jdk 5.0 新增的创建多线程的方式</h3>
<h4 id="callable">Callable</h4>
<p>创建多线程的第三种方式，实现Callable 接口
这中方式较之前实现Runnable 的方式相比。多了返回值
但是需要知道，Callable并不是Thread 的子类，所以，想要启动的话，需要借助 Future接口
Future 接口中有唯一的实现类 FutureTask，同时FutureTask也实现了Runnable接口</p>
<p>Callable 的优点</p>
<ul>
<li>可以返回值</li>
<li>可以抛出异常，被外面的操作捕获</li>
<li>支持范型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CallableNewThread</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">NewThread</span> <span class="n">newThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NewThread</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">FutureTask</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">futureTask</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FutureTask</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">newThread</span><span class="o">)</span><span class="o">;</span>

        <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">futureTask</span><span class="o">)</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//futuretask 的get方法会去调用-&gt;构造参数传入的对象的call（回调）方法
</span><span class="c1"></span>            <span class="n">Integer</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">futureTask</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">NewThread</span> <span class="kd">implements</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">call</span><span class="o">(</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">100</span><span class="o">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">2</span> <span class="o">=</span><span class="o">=</span> <span class="n">0</span><span class="o">)</span><span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="o">;</span>
                <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span><span class="c1">//自动装箱，变为Integer类型
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="线程池">线程池</h4>
<p>线程池的好处</p>
<ul>
<li>提高响应速度，减少了创建线程的时间</li>
<li>降低资源消耗，重复利用线程池中的线程</li>
<li>便于线程管理</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadPool</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建线程池
</span><span class="c1"></span>        <span class="n">ExecutorService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">10</span><span class="o">)</span><span class="o">;</span>

        <span class="n">service</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="o">(</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">100</span><span class="o">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">2</span> <span class="o">=</span><span class="o">=</span> <span class="n">0</span><span class="o">)</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span><span class="o">+</span><span class="s">&#34;:打印-&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span><span class="o">)</span><span class="o">;</span><span class="c1">//适合使用Runnable，没有返回值
</span><span class="c1"></span>        <span class="n">Future</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="o">(</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">100</span><span class="o">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">2</span> <span class="o">!</span><span class="o">=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;:打印-&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
        <span class="o">}</span><span class="o">)</span><span class="o">;</span><span class="c1">//适合使用于Callable，返回Future
</span><span class="c1"></span>
        <span class="n">Integer</span> <span class="n">integer</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">integer</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">integer</span><span class="o">)</span><span class="o">;</span>

        <span class="c1">//关闭线程池
</span><span class="c1"></span>        <span class="n">service</span><span class="o">.</span><span class="na">shutdown</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>如果需要对线程池进行设置的话，不能直接使用ExecuteService 对象，因为这是一个接口
我们可以将它进行强转（向下转型），找它的实现类，ThreadPollExecutor，然后进行相关设置</p>
</article><section class="article labels"><a class="category" href=/categories/java/>java</a><a class="tag" href=/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/>多线程</a></section></div><section class="article navigation"><p><a class="link" href="/post/shiro2/"><span class="li">&rarr;</span>Shiro 中简单的认证和角色权限管理</a></p></section></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">©2020 gejigejiemmm.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></div>
</body>

</html>